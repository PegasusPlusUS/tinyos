# common.mk
# TODO: Need IA16-elf-gcc, IA16-elf-ld, and IA16-elf-as, otherwise, function can not take param. Current BIOS_xxx are all macros,
# 	which are not function, they uses fixed static memory to pass param to asm functions, not stack (i686-elf-gcc has bug that uses 32bit stack register which cause trouble in bootsector 16bit real mode).
#   or try initialize 32bit ss and esp to see if that can work.
# 1. Lang -> Target, asm
# 2. Lang -> ASM -> Obj -> Target, C (For some unknown reason, the target file generated by ia-16 is over 560 bytes, have to change as ia-16 compile to asm, i686-elf-as compile to obj, i686-elf-ld link to target)
# 3. Lang -> Ci -> Cr -> 2., v, bas, nim, .. f90, pascal (with p2c) 
# 4. Lang -> lib.a path, swift/go and c can not access memory directly, must use function call, which will be ready after ia16-toolchain is ready or init 32bit ss/esp works. This path might not possible for the size of the code.
# 5. Lang -> ASMi -> ASMr -> Obj -> Target, pascal (generate asm)
# 6. Lang -> WASM path, VM translate to C, zig, tinygo, moonbit
# 7. Lang -> LLVMIR path, LLVMIR to C, or LLVMIR to ASM?
#

# To use this common.mk, c just include ../common.mk; asm define LANG_SUFFIX=asm then include ../common.mk;
# For other languages, you need to define the following variables in your Makefile:
# 1. LANG_SUFFIX: the suffix of the source file, e.g., .nim, .v, .bas, .pas, .go, .zig, .swift, .f90
# 2. EXE_LANG_COMPILER: the executable name of the compiler, e.g., nim, v, fbc, fpc, go, zig, swift, gfortran
# 3. FLAGS_LANG_TO_C: the flags to pass to the compiler, e.g., -r, -freestanding, -c --genScript --cc:gcc --compileOnly --out:
# 4. Optional: FILES_SOURCE_SET: the source files set representation, e.g., . for V
# 5. Optional: FILES_SOURCE_DEPENDENCIES: the dependencies for the source file, e.g., common.$(LANG_SUFFIX), common_bios.$(LANG_SUFFIX)
# 6. Optional: FILES_SOURCE_ADDITIONAL_DEPENDENCIES: the additional dependencies for the source file, e.g., main.v
# 7. Optional: SCRIPT_LANG_TO_C_POST_PROCESSING: the post processing command to run after the source file is compiled to C,
#   e.g., cp ~/nimcache/$(BOOTSECTOR)_d/@m$(FILE_LANG_TO_C_INITIAL_RESULT) $(FILE_LANG_TO_C_INITIAL_RESULT) 
# 8. Optional: C_DEPENDENCIES: the dependencies for the C code, e.g., ../c/common_prefix.h ../c/bootsector.h ../c/common_suffix.h
# 9. Optional: C_LANG_DEPENDENCIES: the dependencies for the C code of LANG, e.g., common_prefix.$(LANG_SUFFIX).h common_suffix.$(LANG_SUFFIX).h $(C_DEPENDENCIES)
#
# common.mk assumes:
# 1. There is a filter_$(LANG_SUFFIX)_to_c_result.awk file to filter initial C code to final C code.
# 2. There is a common_prefix.$(LANG_SUFFIX).h, common_suffix.$(LANG_SUFFIX).h, and common_bios.$(LANG_SUFFIX) file.
# 3. The final C code will be compiled to an object file, and then linked to a binary file as target which named 'bootsector.bin'.
# 4. The target file will be verified by a verify script, and then tested by a test script to start QEMU VM load target as bootsector.
# 5. Under AV, the target file will be packed as a .pz file, and then verified by a verify script, and then tested by a test script to start QEMU VM load target as bootsector.
#
# common.mk provides the following targets:
# 1. default: the run target will build the binary file, verify it, and then run it.
# 2. build: the build target will build the binary file, verif it.
# 3. build_under_av: the build_under_av target will build the packed binary file, verify it.
# 4. run_under_av: the run_under_av target will build the packed binary file, verify it, and then run it.
# 5. neat: the neat target will remove all intermediate files.
# 6. clean: the clean target will remove all intermediate files and the target file.
# 7. check_asm: sometimes, you may want to check the generated asm code to debug ridiculous bug, for example,
#   currently i686-elf-gcc can't always generate 16bit asm code, especially, it uses 32bit stack registers for
#   params, which causes accessing the stack variable or passing param to function hang the VM. You can use
#   this target to generate the asm code for deep debugging.
#


# Disable default rules by overriding them with empty rules
.SUFFIXES:

TITLE?=bootsector

all: run

.PHONY : run build check_asm neat clean run_under_av

SHELL?=/usr/bin/bash

BOOTSECTOR=bootsector
BASE_DIR?=../../ch01_bootsector/
FILES_BUILD_RULES?=Makefile $(BASE_DIR)common.mk
FILE_TARGET=$(BOOTSECTOR).bin

# Common rules and variables
# Path to ia-16 gcc: /home/ping/study/gcc-ia16/host-x86_64-pc-linux-gnu/gcc/xgcc, cc1

OS := $(shell uname)

ifeq ($(OS), Linux)
EXE_C_COMPILER?=/opt/gcc-ia16/bin/ia16-elf-gcc
FLAGS_CC?=-Os -fshort-enums -finline-limit=0 -fno-inline -falign-functions=1 \
	-falign-jumps=1 -falign-loops=1 \
	-fcall-used-ax -fcall-used-dx -ffreestanding -fno-pie \
        -nostdlib -nostdinc -fno-asynchronous-unwind-tables \
        -fno-builtin -fno-stack-protector
else
EXE_C_COMPILER?=i686-elf-gcc
FLAGS_CC?=-Os -finline-limit=0 -fno-inline -falign-functions=1 \
	-falign-jumps=1 -falign-loops=1 -march=i386 \
	-fcall-used-ax -fcall-used-dx -ffreestanding -fno-pie \
        -nostdlib -nostdinc -fno-asynchronous-unwind-tables \
        -fno-builtin -fno-stack-protector
endif
FLAGS_C_TO_ASM?=$(FLAGS_CC) -S -o 
EXE_ASM_COMPILER?=i686-elf-as
FLAGS_ASM_TO_O?=-o 
EXE_FILTER?=awk
EXE_LINK=i686-elf-ld
FLAGS_LINK=-T $(BASE_DIR)c/linker.ld --oformat binary -s

ifdef LANG_SUFFIX
ifeq ($(LANG_SUFFIX), asm)
EXE_LANG_COMPILER?=nasm
FLAGS_COMPILER2TARGET?=-o 
PIPE_LINE_SKIP_TO_C=true
else
PIPE_LINE_SKIP_TO_C=false
endif
endif

ifndef LANG_SUFFIX
LANG_SUFFIX=c
PIPE_LINE_SKIP_TO_C=true
endif


# CI_PIPE_LINE_START
FILES_SOURCE_COMMOM_PREFIX?=$(BASE_DIR)$(LANG_SUFFIX)/
FILES_SOURCE_DEPENDENCIES?=$(FILES_SOURCE_COMMOM_PREFIX)common_bios.$(LANG_SUFFIX)
FILE_SOURCE?=$(BOOTSECTOR).$(LANG_SUFFIX)

FILE_LANG_TO_C_FINAL_RESULT=$(BOOTSECTOR).c
ifneq ($(PIPE_LINE_SKIP_TO_C), true)
# 1. Lang to C initial
# Define FILE_SOURCE and FILE_LANG_TO_C_INITIAL_RESULT
FILE_LANG_TO_C_INITIAL_RESULT?=$(FILE_SOURCE).c
SCRIPT_LANG_TO_C_POST_PROCESSING?=echo "\# $(FILE_SOURCE) to $(FILE_LANG_TO_C_INITIAL_RESULT) succeeded!"
# Rule to build FILE_LANG_TO_C_INITIAL_RESULT
FILES_SOURCE_SET?=$(FILE_SOURCE)
$(FILE_LANG_TO_C_INITIAL_RESULT): $(FILE_SOURCE) $(FILES_SOURCE_DEPENDENCIES) $(FILES_SOURCE_ADDITIONAL_DEPENDENCIES) $(FILES_BUILD_RULES)
	@echo "# Compile $(FILE_SOURCE) to $(FILE_LANG_TO_C_INITIAL_RESULT) by $(EXE_LANG_COMPILER)."
	@$(EXE_LANG_COMPILER) $(FLAGS_LANG_TO_C)$(FILE_LANG_TO_C_INITIAL_RESULT) $(FILES_SOURCE_SET)
	@$(SCRIPT_LANG_TO_C_POST_PROCESSING)

# 2. Filter C initial to final
SCRIPT_FILTER_LANG_TO_C=$(FILES_SOURCE_COMMOM_PREFIX)filter_$(LANG_SUFFIX)_to_c_result.awk
$(FILE_LANG_TO_C_FINAL_RESULT): $(FILE_LANG_TO_C_INITIAL_RESULT) $(SCRIPT_FILTER_LANG_TO_C) $(FILES_BUILD_RULES)
	@echo "# Filter out unneeded code and add necessary reused functions and $(BOOTSECTOR) signature from ../c/$(BOOTSECTOR).h by $(EXE_FILTER)."
	@$(EXE_FILTER) -f $(SCRIPT_FILTER_LANG_TO_C) $(FILE_LANG_TO_C_INITIAL_RESULT) > $(FILE_LANG_TO_C_FINAL_RESULT)
endif

ifneq ($(LANG_SUFFIX), asm)
# 3 final C to ASM
FILE_ASM_RESULT=$(FILE_SOURCE).asm
C_DEPENDENCIES?=$(BASE_DIR)c/common_prefix.h $(BASE_DIR)c/bootsector.h $(BASE_DIR)c/common_suffix.h
C_LANG_DEPENDENCIES?=$(C_DEPENDENCIES)
ifneq ($(LANG_SUFFIX), c)
C_LANG_DEPENDENCIES=$(C_DEPENDENCIES) $(FILES_SOURCE_COMMOM_PREFIX)common_prefix.$(LANG_SUFFIX).h $(FILES_SOURCE_COMMOM_PREFIX)common_suffix.$(LANG_SUFFIX).h
endif

$(FILE_ASM_RESULT): $(FILE_LANG_TO_C_FINAL_RESULT) $(C_LANG_DEPENDENCIES) $(FILES_BUILD_RULES)
	@echo "# Compile $(FILE_LANG_TO_C_FINAL_RESULT) to $(FILE_ASM_RESULT) by $(notdir $(EXE_C_COMPILER))."
	@$(EXE_C_COMPILER) $(FLAGS_C_TO_ASM)$(FILE_ASM_RESULT) $(FILE_LANG_TO_C_FINAL_RESULT)

# 4. ASM to Obj
FILE_OBJ_RESULT=$(BOOTSECTOR).o
C_DEPENDENCIES?=$(BASE_DIR)c/common_prefix.h $(BASE_DIR)c/bootsector.h $(BASE_DIR)c/common_suffix.h
C_LANG_DEPENDENCIES?=$(C_DEPENDENCIES)
ifneq ($(LANG_SUFFIX), c)
C_LANG_DEPENDENCIES=$(C_DEPENDENCIES) $(FILES_SOURCE_COMMOM_PREFIX)common_prefix.$(LANG_SUFFIX).h $(FILES_SOURCE_COMMOM_PREFIX)common_suffix.$(LANG_SUFFIX).h
endif

$(FILE_OBJ_RESULT): $(FILE_ASM_RESULT) $(FILES_BUILD_RULES)
	@echo "# Compile $(FILE_ASM_RESULT) to $(FILE_OBJ_RESULT) by $(notdir $(EXE_ASM_COMPILER))."
	@$(EXE_ASM_COMPILER) $(FLAGS_ASM_TO_O)$(FILE_OBJ_RESULT) $(FILE_ASM_RESULT)

# 5. Link object to target
# Link object to binary
ifneq ($(LANG_SUFFIX), asm)
$(FILE_TARGET): $(FILE_OBJ_RESULT)
	@echo "# Link $(FILE_OBJ_RESULT) to $(FILE_TARGET) by $(EXE_LINK)."
	@$(EXE_LINK) $(FLAGS_LINK) -o $(FILE_TARGET) $(FILE_OBJ_RESULT)
endif
else
# 1. ASM to target
$(FILE_TARGET): $(FILE_SOURCE) $(FILES_SOURCE_DEPENDENCIES) $(FILES_SOURCE_ADDITIONAL_DEPENDENCIES) $(FILES_BUILD_RULES)
	@echo "# Compile $(FILE_SOURCE) to $(FILE_TARGET) by $(EXE_LANG_COMPILER)."
	@$(EXE_LANG_COMPILER) $(FLAGS_COMPILER2TARGET) $(FILE_TARGET) $(FILE_SOURCE)
endif

# Verify and test scripts
SCRIPT_VERIFY?=$(BASE_DIR)verify_boot.sh
SCRIPT_TEST?=$(BASE_DIR)test.qemu.sh

# Build target
build: $(FILE_TARGET)
	@echo "# Verify $(FILE_TARGET) is valid $(BOOTSECTOR)."
	@$(SHELL) $(SCRIPT_VERIFY)

ifneq ($(LANG_SUFFIX), asm)
check_asm: $(FILE_ASM_RESULT)
	@echo "# Check $(FILE_ASM_RESULT) for debugging."
	@code $(FILE_ASM_RESULT)

# $(FILE_C_TO_ASM_RESULT): $(FILE_LANG_TO_C_FINAL_RESULT) $(FILES_BUILD_RULES)
# 	@echo "# Compile $(FILE_LANG_TO_C_FINAL_RESULT) to $(FILE_C_TO_ASM_RESULT) by $(EXE_C_COMPILER)."
# 	@$(EXE_C_COMPILER) $(FLAGS_C_TO_ASM) $(FILE_C_TO_ASM_RESULT) $(FILE_LANG_TO_C_FINAL_RESULT)
endif

neat:
	rm -f *.o *.s *.pz
ifneq ($(LANG_SUFFIX), c)
	rm -f *.c
endif
ifneq ($(LANG_SUFFIX), asm)
	rm -f *.asm
endif

clean: neat
	rm -f $(FILE_TARGET)

# Using VM to boot from target
run: build
	@echo "# Run QEMU VM with 1M memory to load $(FILE_TARGET) as disk image for boot device"
	$(SHELL) $(SCRIPT_TEST)
